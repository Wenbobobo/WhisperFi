import { expect } from "chai";
import { ethers } from "hardhat";
import { Signer, Contract } from "ethers";

// Helper function to generate a mock proof
// In a real scenario, this would be generated by a ZK-SNARK prover
const generateMockProof = (): [string[], string[][], string[]] => {
  const pA: [string, string] = ["0", "0"];
  const pB: [[string, string], [string, string]] = [["0", "0"], ["0", "0"]];
  const pC: [string, string] = ["0", "0"];
  return [pA, pB, pC];
};

describe("PrivacyPool", function () {
  let owner: Signer;
  let verifier: Contract;
  let privacyPool: Contract;
  let executor: Contract;

  beforeEach(async function () {
    [owner] = await ethers.getSigners();

    // Deploy the actual Verifier contract
    const Verifier = await ethers.getContractFactory("Verifier");
    verifier = await Verifier.deploy();
    await verifier.waitForDeployment();

    const Executor = await ethers.getContractFactory("Executor");
    executor = await Executor.deploy(await owner.getAddress());
    await executor.waitForDeployment();

    const initialRoot = ethers.encodeBytes32String("initialRoot");
    const PrivacyPool = await ethers.getContractFactory("PrivacyPool");
    privacyPool = await PrivacyPool.deploy(
      await verifier.getAddress(),
      initialRoot,
      await owner.getAddress()
    );
    await privacyPool.waitForDeployment();
  });

  describe("Deployment", function () {
    it("should set the correct owner and verifier", async function () {
      expect(await privacyPool.owner()).to.equal(await owner.getAddress());
      expect(await privacyPool.verifier()).to.equal(await verifier.getAddress());
    });
  });

  describe("Deposit", function () {
    it("should deposit a commitment and update the root", async function () {
      const commitment = ethers.randomBytes(32);
      const initialRoot = await privacyPool.root();

      const tx = await privacyPool.deposit(commitment);
      const receipt = await tx.wait();
      const block = await ethers.provider.getBlock(receipt.blockNumber);
      const timestamp = block!.timestamp;

      await expect(tx)
        .to.emit(privacyPool, "Deposit")
        .withArgs(ethers.hexlify(commitment), 0, timestamp);

      const newRoot = await privacyPool.root();
      expect(newRoot).to.not.equal(initialRoot);
    });
  });

  describe("Withdraw", function () {
    it("should fail if Merkle root is invalid", async function () {
      const [pA, pB, pC] = generateMockProof();
      const invalidRoot = ethers.randomBytes(32);
      const nullifier = ethers.randomBytes(32);
      const recipient = await owner.getAddress();
      const amount = ethers.parseEther("1");

      await expect(
        privacyPool.withdraw(pA, pB, pC, invalidRoot, nullifier, recipient, amount)
      ).to.be.revertedWith("Invalid Merkle root");
    });

    it("should fail for an invalid proof", async function () {
        const commitment = ethers.randomBytes(32);
        await privacyPool.deposit(commitment);
        const currentRoot = await privacyPool.root();

        const [pA, pB, pC] = generateMockProof(); // This is a mock proof
        const nullifier = ethers.randomBytes(32);
        const recipient = await owner.getAddress();
        const amount = ethers.parseEther("1");

        // The Verifier will return false for this mock proof
        await expect(
            privacyPool.withdraw(pA, pB, pC, currentRoot, nullifier, recipient, amount)
        ).to.be.revertedWith("Invalid proof");
    });
  });

  describe("Trade", function () {
    it("should fail if Merkle root is invalid", async function () {
      const [pA, pB, pC] = generateMockProof();
      const invalidRoot = ethers.randomBytes(32);
      const nullifier = ethers.randomBytes(32);
      const newCommitment = ethers.randomBytes(32);
      const tradeDataHash = ethers.randomBytes(32);
      const target = await owner.getAddress();
      const callData = "0x";

      await expect(
        privacyPool.trade(pA, pB, pC, invalidRoot, nullifier, newCommitment, tradeDataHash, await executor.getAddress(), target, callData)
      ).to.be.revertedWith("Invalid Merkle root");
    });

    it("should fail for an invalid proof", async function () {
        const commitment = ethers.randomBytes(32);
        await privacyPool.deposit(commitment);
        const currentRoot = await privacyPool.root();

        const [pA, pB, pC] = generateMockProof();
        const nullifier = ethers.randomBytes(32);
        const newCommitment = ethers.randomBytes(32);
        const tradeDataHash = ethers.randomBytes(32);
        const target = await owner.getAddress();
        const callData = "0x";

        await expect(
            privacyPool.trade(pA, pB, pC, currentRoot, nullifier, newCommitment, tradeDataHash, await executor.getAddress(), target, callData)
        ).to.be.revertedWith("Invalid proof");
    });
  });
});