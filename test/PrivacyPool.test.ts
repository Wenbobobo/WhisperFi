import { expect } from "chai";
import { ethers } from "hardhat";
import { Signer } from "ethers";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import {
  deployTestEnvironment,
  TestEnvironment,
} from "./environment";
import {
  PrivacyPool,
  Groth16Verifier,
} from "../typechain-types";

// Helper function to generate a mock proof for testing purposes.
// In a real scenario, this would be generated by a ZK-SNARK prover.
const generateMockProof = (): [
  [string, string],
  [[string, string], [string, string]],
  [string, string]
] => {
  const pA: [string, string] = ["0", "0"];
  const pB: [[string, string], [string, string]] = [["0", "0"], ["0", "0"]];
  const pC: [string, string] = ["0", "0"];
  return [pA, pB, pC];
};

describe("PrivacyPool", function () {
  let env: TestEnvironment;
  let owner: Signer;
  let verifier: Groth16Verifier;
  let privacyPool: PrivacyPool;

  beforeEach(async function () {
    env = await loadFixture(deployTestEnvironment);
    owner = env.owner;
    verifier = env.verifier;
    privacyPool = env.privacyPool;
  });

  describe("Deployment", function () {
    it("should set the correct owner and verifier", async function () {
      expect(await privacyPool.owner()).to.equal(await owner.getAddress());
      expect(await privacyPool.verifier()).to.equal(await verifier.getAddress());
    });
  });

  describe("Deposit", function () {
    it("should deposit a commitment and update the root", async function () {
      const commitment = ethers.randomBytes(32);
      const initialRoot = await privacyPool.merkleRoot();

      const depositAmount = await privacyPool.DEPOSIT_AMOUNT();
      const tx = await privacyPool.deposit(commitment, { value: depositAmount });
      const receipt = await tx.wait();
      const block = await ethers.provider.getBlock(receipt!.blockNumber);
      const timestamp = block!.timestamp;

      await expect(tx)
        .to.emit(privacyPool, "Deposit")
        .withArgs(ethers.hexlify(commitment), 0, timestamp);

      const newRoot = await privacyPool.merkleRoot();
      expect(newRoot).to.not.equal(initialRoot);
    });
  });

  describe("Withdraw", function () {
    it("should fail if Merkle root is invalid", async function () {
      const [pA, pB, pC] = generateMockProof();
      const invalidRoot = ethers.randomBytes(32);
      const nullifier = ethers.randomBytes(32);
      const recipient = await owner.getAddress();
      const amount = ethers.parseEther("1");

      await expect(
        privacyPool.withdraw(pA, pB, pC, invalidRoot, nullifier, recipient, amount)
      ).to.be.revertedWith("Invalid Merkle root");
    });

    it("should fail for an invalid proof", async function () {
      const commitment = ethers.randomBytes(32);
      const depositAmount = await privacyPool.DEPOSIT_AMOUNT();
      await privacyPool.deposit(commitment, { value: depositAmount });
      const currentRoot = await privacyPool.merkleRoot();

      const [pA, pB, pC] = generateMockProof(); // This is a mock proof
      const nullifier = ethers.randomBytes(32);
      const recipient = await owner.getAddress();
      const amount = ethers.parseEther("1");

      // The Verifier will return false for this mock proof
      await expect(
        privacyPool.withdraw(pA, pB, pC, currentRoot, nullifier, recipient, amount)
      ).to.be.revertedWith("Invalid proof");
    });
  });

});