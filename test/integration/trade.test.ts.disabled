/*
 * NOTE: The trade functionality is temporarily disabled.
 * The current implementation has design flaws and requires a full architectural redesign
 * before being re-enabled. This test suite should only be re-activated after
 * the new trade architecture is complete.
 *
 * Reasons for disabling the trade functionality:
 * 1. The current implementation has design flaws and requires a complete architectural redesign.
 * 2. The ZK-circuit proof generation logic needs further optimization and validation.
 * 3. The interaction flow between the Relayer and the contracts needs to be reviewed and improved.
 * 4. The overall security and reliability of the trade functionality need to be re-evaluated.
 *
 * Plan: Re-enable this test suite after the new trade architecture is complete.
 */

// test/integration/trade.test.ts
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { deployTestEnvironment, TestEnvironment } from "../environment";
// @ts-ignore - circomlibjs doesn't have TypeScript declarations
import { buildPoseidon } from "circomlibjs";
import path from "path";

// Import Relayer components (Node.js modules)
const dbModule = require("../../relayer/database");
const IntentProcessor = require("../../relayer/processor");

/**
 * @notice Integration tests for the core Relayer processor.
 * @dev This is an atomic integration test that is independent of the Express API server.
 * It directly tests the core processor module at the code level to verify its business logic.
 */
describe("Relayer Trade Processing Integration", function () {
  let env: TestEnvironment;
  let poseidon: any;
  let processor: any;
  let smartAccountAddress: string;

  // Test constants
  const WETH_AMOUNT = ethers.parseEther("1.0"); // 1 WETH
  const EXPECTED_USDC_MIN = ethers.parseUnits("1000", 6); // Minimum expected 1000 USDC

  // Use a unique secret for each test to avoid nullifier collisions
  let currentTestSecret: string;

  before(async function () {
    // Initialize the real Poseidon hasher to be consistent with the frontend and contracts
    poseidon = await buildPoseidon();

    // Initialize the test database
    await dbModule.setupDatabase();
  });

  beforeEach(async function () {
    // Generate a unique secret for each test to avoid nullifier collisions
    currentTestSecret = `test-secret-${Date.now()}-${Math.random().toString(
      36
    )}`;

    // Clear old data from the database
    await dbModule.clearAllIntents();

    // Use the standard fixture pattern to get a clean test environment
    env = await loadFixture(deployTestEnvironment);
    const { factory, user, owner, weth, usdc, mockUniswapRouter } = env;

    // Create a new smart account for each test
    const userAddress = await user.getAddress();
    await factory.createAccount(userAddress, 0);
    smartAccountAddress = await factory.getAccountAddress(userAddress, 0);

    // Send some ETH to the smart account for gas
    await owner.sendTransaction({
      to: smartAccountAddress,
      value: ethers.parseEther("2"),
    });

    // Send WETH to the smart account as input funds for the trade
    await weth.mint(smartAccountAddress, WETH_AMOUNT);

    // Create a fixed relayer wallet and fund it with ETH
    const relayerPrivateKey =
      "0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d"; // Hardhat account #2
    const relayerWallet = new ethers.Wallet(relayerPrivateKey, ethers.provider);

    // Send ETH to the relayer wallet for gas fees
    await env.owner.sendTransaction({
      to: relayerWallet.address,
      value: ethers.parseEther("10"), // Send 10 ETH
    });

    // Initialize the processor (instantiated directly, without starting the Express server)
    processor = new IntentProcessor(env.privacyPool, ethers.provider, {
      chainId: 31337, // Local test network
      flashbotsKey: relayerPrivateKey, // Use a funded test account
    });

    // Configure token addresses for the test environment
    processor.uniswapEncoder.addCustomToken(
      "WETH",
      await env.weth.getAddress(),
      18,
      "Wrapped Ethereum"
    );
    processor.uniswapEncoder.addCustomToken(
      "USDC",
      await env.usdc.getAddress(),
      6,
      "USD Coin"
    );

    // Configure the MockUniswapRouter
    const mockRouterAddress = await mockUniswapRouter.getAddress();

    // Override the Uniswap Router address in the processor
    processor.uniswapEncoder.SWAP_ROUTER_ADDRESS = mockRouterAddress;

    // Fund the MockUniswapRouter with USDC so it can perform swaps
    const usdcForRouter = ethers.parseUnits("100000", 6); // 100,000 USDC
    await usdc.mint(mockRouterAddress, usdcForRouter);

    // Set a fixed exchange rate for WETH -> USDC (1 WETH = 2000 USDC)
    const exchangeRate = ethers.parseUnits("2000", 6); // 2000 USDC per WETH
    await mockUniswapRouter.setExchangeRate(
      await weth.getAddress(),
      await usdc.getAddress(),
      exchangeRate
    );

    // Critical: Approve the MockUniswapRouter to spend the Smart Account's WETH
    // This allows the MockUniswapRouter to execute transferFrom
    const maxUint256 = ethers.MaxUint256;
    const smartAccountWethContract = weth.connect(
      await ethers.getImpersonatedSigner(smartAccountAddress)
    );
    await smartAccountWethContract.approve(mockRouterAddress, maxUint256);
  });

  /**
   * @notice Core test case: processing a valid trade intent.
   * @dev This test covers the complete Relayer processing flow:
   * 1. Arrange: Deposit to get a Note, send WETH to the smart account.
   * 2. Create a valid trade intent and insert it into the database.
   * 3. Act: Directly call `processor.processPendingIntents()`.
   * 4. Assert: Verify database state changes (pending -> confirmed).
   * 5. Assert: Verify on-chain state changes (nullifier, commitment, token balances).
   */
  describe("Core Trade Processing", function () {
    it("should process a valid trade intent", async function () {
      this.timeout(60000); // Set a longer timeout for ZK proof generation

      // === Arrange ===
      // 1. Deposit into the PrivacyPool for the test user to get a valid Note
      const { commitment, nullifier } = await preparePrivacyPoolDeposit();

      // 2. Verify the smart account's WETH balance
      const initialWethBalance = await env.weth.balanceOf(smartAccountAddress);
      const initialUsdcBalance = await env.usdc.balanceOf(smartAccountAddress);

      expect(initialWethBalance).to.equal(
        WETH_AMOUNT,
        "Smart account should have 1 WETH"
      );
      expect(initialUsdcBalance).to.equal(
        0,
        "Smart account initial USDC balance should be 0"
      );

      // 3. Create a valid trade intent
      const tradeIntent = await createValidTradeIntent(commitment, nullifier);

      // 4. Insert the trade intent into the database
      const intentId = dbModule.generateIntentId();
      await dbModule.createIntent(intentId, JSON.stringify(tradeIntent));

      // === Act ===
      // Set up an event listener to track calls to the MockUniswapRouter
      const mockRouter = env.mockUniswapRouter;
      const swapCalledEvents: any[] = [];

      const swapCalledFilter = mockRouter.filters.SwapCalled();
      mockRouter.on(
        swapCalledFilter,
        (caller, tokenIn, tokenOut, amountIn, amountOut) => {
          swapCalledEvents.push({
            caller,
            tokenIn,
            tokenOut,
            amountIn,
            amountOut,
          });
        }
      );

      // Directly call the processor's core function
      await processor.processPendingIntents();

      // === Assert ===
      // 1. Database state assertions
      await verifyDatabaseState(intentId);

      // 2. On-chain state assertions
      await verifyOnChainState(nullifier, commitment);
    });
  });

  /**
   * @dev Prepares a PrivacyPool deposit and returns the commitment and nullifier.
   */
  async function preparePrivacyPoolDeposit() {
    const { privacyPool, user } = env;

    // Use the unique secret for the current test
    const secretHash = ethers.keccak256(ethers.toUtf8Bytes(currentTestSecret));
    const depositAmount = await privacyPool.DEPOSIT_AMOUNT();

    // Generate commitment and nullifier using the same logic as the frontend
    const commitment = generateCommitment(secretHash, depositAmount);
    const nullifier = generateNullifierHash(secretHash);

    // Execute the deposit
    const tx = await privacyPool.connect(user).deposit(commitment, {
      value: depositAmount,
    });
    await tx.wait();

    return { commitment, nullifier };
  }

  /**
   * @dev Creates a valid trade intent object.
   */
  async function createValidTradeIntent(commitment: string, nullifier: string) {
    // Generate the tradeDataHash consistent with the contract's logic
    const tradeDataHash = generateTradeDataHash(
      smartAccountAddress,
      WETH_AMOUNT
    );

    // Mock ZK proof parameters here.
    // In a real scenario, these would be generated by the frontend ZK circuit.
    return {
      // ZK proof parameters (mocked)
      pA: ["0x1", "0x2"],
      pB: [
        ["0x3", "0x4"],
        ["0x5", "0x6"],
      ],
      pC: ["0x7", "0x8"],
      proofRoot: await env.privacyPool.merkleRoot(),
      nullifier: nullifier,
      newCommitment: ethers.hexlify(ethers.randomBytes(32)), // New change commitment
      tradeDataHash: tradeDataHash,

      // Trade intent details
      tradeIntent: {
        tokenIn: "WETH",
        tokenOut: "USDC",
        amountIn: WETH_AMOUNT.toString(),
        slippage: "0.5",
      },
      recipient: smartAccountAddress,
      executor: smartAccountAddress,
    };
  }

  /**
   * @dev Verifies the state of the database.
   */
  async function verifyDatabaseState(intentId: string) {
    const intent = await dbModule.getIntentById(intentId);

    expect(intent).to.not.be.null;
    expect(intent.status).to.equal(
      "confirmed",
      "Intent status should change from pending to confirmed"
    );
  }

  /**
   * @dev Verifies the state of the blockchain.
   */
  async function verifyOnChainState(nullifier: string, oldCommitment: string) {
    const { privacyPool, weth, usdc } = env;

    // Verify the nullifier has been used
    const isNullifierUsed = await privacyPool.nullifiers(nullifier);
    expect(isNullifierUsed).to.be.true;

    // Verify token balance changes
    const finalWethBalance = await weth.balanceOf(smartAccountAddress);
    const finalUsdcBalance = await usdc.balanceOf(smartAccountAddress);

    expect(finalWethBalance).to.be.lessThan(
      WETH_AMOUNT,
      "Smart account's WETH balance should decrease"
    );
    expect(finalUsdcBalance).to.be.greaterThan(
      0,
      "Smart account should receive USDC"
    );
  }

  /**
   * @dev Helper function to convert a Poseidon hash result to a BigInt.
   * @param hash The hash result from circomlibjs.
   * @returns The hash as a BigInt.
   */
  function poseidonResultToBigInt(hash: any): bigint {
    // circomlibjs poseidon function can return a Uint8Array or a BigInt
    if (typeof hash === "bigint") {
      return hash;
    }

    if (Array.isArray(hash) || hash instanceof Uint8Array) {
      const bytes = Array.from(hash);
      const hexString =
        "0x" + bytes.map((b) => b.toString(16).padStart(2, "0")).join("");
      return BigInt(hexString);
    }

    if (hash && typeof hash.toString === "function") {
      const str = hash.toString();
      return str.startsWith("0x") ? BigInt(str) : BigInt(str);
    }

    // Fallback for other potential types
    return BigInt(hash);
  }

  /**
   * @dev Generates a commitment using the actual Poseidon implementation.
   * @param secret The secret key.
   * @param amount The amount for the commitment.
   * @returns The commitment hash.
   */
  function generateCommitment(secret: string, amount: bigint): string {
    const secretBigInt = BigInt(secret);
    const hash = poseidon([secretBigInt, amount]);
    const hashBigInt = poseidonResultToBigInt(hash);
    return ethers.toBeHex(hashBigInt, 32);
  }

  /**
   * @dev Generates a nullifier hash using the actual Poseidon implementation.
   * @param secret The secret key.
   * @returns The nullifier hash.
   */
  function generateNullifierHash(secret: string): string {
    const secretBigInt = BigInt(secret);
    const hash = poseidon([secretBigInt]);
    const hashBigInt = poseidonResultToBigInt(hash);
    return ethers.toBeHex(hashBigInt, 32);
  }

  // Simplified Poseidon implementation to match the contract's logic for compatibility.
  const FIELD_SIZE =
    21888242871839275222246405745257275088548364400416034343698204186575808495617n;
  const C0 =
    0x109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118bn;
  const C1 =
    0x16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e0n;
  const C2 =
    0x2b90bba00fca0589f617e7dcbfe82e0df706ab640ceb247b791a93b74e36736dn;

  /**
   * @dev Modular exponentiation.
   */
  function powMod(base: bigint, exp: bigint, mod: bigint): bigint {
    let result = 1n;
    base = base % mod;
    while (exp > 0n) {
      if (exp % 2n === 1n) {
        result = (result * base) % mod;
      }
      exp = exp >> 1n;
      base = (base * base) % mod;
    }
    return result;
  }

  /**
   * @dev A simplified Poseidon implementation that exactly matches the contract's logic.
   */
  function simplifiedPoseidon(input: [bigint, bigint]): bigint {
    let x = input[0];
    let y = input[1];

    // Round 1: Add constants
    x = (x + C0) % FIELD_SIZE;
    y = (y + C1) % FIELD_SIZE;

    // S-box (x^5)
    x = powMod(x, 5n, FIELD_SIZE);
    y = powMod(y, 5n, FIELD_SIZE);

    // Linear layer (simplified MDS matrix)
    let t0 = (x + y) % FIELD_SIZE;
    let t1 = (x * 2n + y) % FIELD_SIZE;

    // Round 2
    t0 = (t0 + C2) % FIELD_SIZE;
    t1 = (t1 + C0) % FIELD_SIZE;

    // Final S-box
    t0 = powMod(t0, 5n, FIELD_SIZE);
    t1 = powMod(t1, 5n, FIELD_SIZE);

    // Final linear layer
    return (t0 + t1) % FIELD_SIZE;
  }

  /**
   * @dev Generates the trade data hash using the correct implementation matching the contract.
   * Contract implementation: poseidonHasher.poseidon([uint256(uint160(_recipient)), _tradeAmount])
   */
  function generateTradeDataHash(recipient: string, amount: bigint): string {
    console.log(`🔢 [测试] generateTradeDataHash 输入参数:`);
    console.log(`  - recipient: ${recipient}`);
    console.log(`  - amount: ${amount}`);
    
    // Convert address to uint256 (same as contract: uint256(uint160(_recipient)))
    const addressAsUint256 = BigInt(recipient);
    console.log(`🔄 [测试] 地址转换为uint256: ${addressAsUint256}`);
    
    // Call poseidon with two parameters: [addressAsUint256, amount]
    const hash = poseidon([addressAsUint256, amount]);
    console.log(`🌟 [测试] poseidon 输入: [${addressAsUint256}, ${amount}]`);
    console.log(`🌟 [测试] poseidon 原始结果:`, hash);
    
    const finalHash = ethers.toBeHex(poseidon.F.toObject(hash), 32);
    console.log(`✅ [测试] 最终哈希结果: ${finalHash}`);
    
    return finalHash;
  }
});
