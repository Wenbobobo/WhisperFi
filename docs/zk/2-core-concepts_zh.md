# ZK 知识库：第二部分（修订版 v2）

## 核心概念：我们协议的密码学原语

为了构建一个功能性的 ZKP 系统，我们需要将抽象概念转化为具体的密码学原语。我们的协议建立在三种这样的原语之上：**承诺方案**、**无效符**和**默克尔树**。

### 1. 承诺方案

承诺方案是一种密码学原语，它允许一方在对一个选定的值（或陈述）进行承诺的同时，向他人隐藏该值，并能够在以后揭示所承诺的值。它是密封、防篡改信封的数字等价物。

承诺方案必须具有两个关键属性：

- **隐藏性：** 从承诺本身不可能确定所承诺的值。
- **约束性：** 一旦做出承诺，就不可能更改所承诺的值。

在我们的协议中，我们使用**基于哈希的承诺方案**。一个私有票据由其`amount`（金额）、`asset type`（资产类型）和一个唯一的、随机生成的`secret`（秘密）定义。承诺是这 ��� 值的哈希：

`commitment = HASH(amount, asset, secret)`

- **`HASH`**：我们使用像 Poseidon 这样对 ZK 友好的哈希函数。这对于高效生成证明至关重要。
- **`commitment`**：这是存储在链上的值。它是一个单一的、伪随机的数字，不透露任何关于基础数据的信息（隐藏性），但由其唯一确定（约束性）。

### 2. 无效符

无效符是在花费承诺时揭示的一段数据，以防止双重花费。它是一次性使用的令牌，与原始承诺有密码学上的联系，但其方式不会揭示它对应于哪个承诺。

在我们的协议中，无效符是票据唯一`secret`的哈希：

`nullifier = HASH(secret)`

当用户希望花费一张票据时，他们必须提供一个 ZK 证明，证明他们知道一个与默克尔树中有效承诺相对应的`secret`。作为此证明的一部分，他们还必须揭示从该`secret`派生的`nullifier`。

然后，`PrivacyPool`智能合约将：

1.  通过检查所有已花费无效符的映射，检查所揭示的`nullifier`是否已被使用。
2.  如果已被使用，则该交易是双重花费尝试，将被拒绝。
3.  如果是新的，合约将接受证明，并将`nullifier`添加到已花费无效符的集合中。

因为`nullifier`仅基于`secret`，而不基于票据的其他组成部分，所 ��� 外部观察者不可能将`nullifier`与原始`commitment`联系起来。这保护了用户交易历史的隐私。

### 3. 默克尔树

默克尔树是一种哈希二叉树，可以高效、安全地验证大型数据集的内容。在我们的协议中，我们使用默克尔树来存储所有有效承诺的集合。

为了证明某个特定的承诺是树的一部分，用户不需要提供整个树。相反，他们提供一个**默克尔路径**，这是从承诺（一个叶节点）到默克尔根的路径上的一组兄弟哈希。

然后，验证者（在我们的例子中是`PrivacyPool`智能合约）可以使用这个默克尔路径重新计算默克尔根。如果计算出的根与合约中存储的官方根匹配，则证明该承诺是该集合的有效成员。

这使我们能够证明用户的票据是有效的、未花费的，而无需透露它是树中数千张票据中的哪一张。

### 总结：ZKP 在行动

当用户进行私人交易时，他们正在生成一个 ZK 证明，该证明同时证明以下陈述：

1.  “我知道一个`secret`和一个`amount`，当它们一起哈希时，会产生一个`commitment`，该`commitment`是当前`merkleRoot`下默克尔树中的一个有效叶子。”
2.  “我正在揭示这个`secret`的正确`nullifier`，并且这个`nullifier`尚未被花费。”
3.  “�� 授权的交易是针对一个特定的`tradeDataHash`。”

这种密码学原语的组合使我们能够构建一个私密、安全和非托管的系统。
